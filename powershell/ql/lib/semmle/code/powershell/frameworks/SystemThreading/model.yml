extensions:
  - addsTo:
      pack: microsoft-sdl/powershell-all
      extensible: typeModel
    data:
    - ["system.int32", "system.threading.interlocked!", "Method[add].ReturnValue"]
    - ["system.boolean", "system.threading.lockcookie!", "Method[op_equality].ReturnValue"]
    - ["system.boolean", "system.threading.monitor!", "Method[isentered].ReturnValue"]
    - ["system.threading.executioncontext", "system.threading.executioncontext", "Method[createcopy].ReturnValue"]
    - ["system.boolean", "system.threading.countdownevent", "Property[isset]"]
    - ["system.threading.lockrecursionpolicy", "system.threading.readerwriterlockslim", "Property[recursionpolicy]"]
    - ["system.intptr", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.uint64", "system.threading.interlocked!", "Method[read].ReturnValue"]
    - ["system.uint16", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.boolean", "system.threading.monitor!", "Method[wait].ReturnValue"]
    - ["system.int16", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int32", "system.threading.threadpool!", "Property[threadcount]"]
    - ["system.uint32", "system.threading.interlocked!", "Method[add].ReturnValue"]
    - ["system.single", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.threading.cancellationtoken", "system.threading.cancellationtokenRegistration", "Property[token]"]
    - ["system.threading.lazythreadsafetymode", "system.threading.lazythreadsafetymode!", "Field[none]"]
    - ["system.int32", "system.threading.countdownevent", "Property[currentcount]"]
    - ["system.object", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.boolean", "system.threading.countdownevent", "Method[tryaddcount].ReturnValue"]
    - ["system.threading.mutex", "system.threading.mutexAcl!", "Method[create].ReturnValue"]
    - ["system.int32", "system.threading.cancellationtokenregistration", "Method[gethashcode].ReturnValue"]
    - ["system.threading.cancellationtokensource", "system.threading.cancellationtokensource!", "Method[createlinkedtokensource].ReturnValue"]
    - ["system.int64", "system.threading.barrier", "Property[currentphasenumber]"]
    - ["system.int32", "system.threading.waithandle!", "Method[waitany].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Field[abovenormal]"]
    - ["system.threading.waithandle", "system.threading.semaphoreslim", "Property[availablewaithandle]"]
    - ["system.threading.tasks.valuetask<system.boolean>", "system.threading.periodictimer", "Method[waitfornexttickasync].ReturnValue"]
    - ["system.int64", "system.threading.timer!", "Property[activecount]"]
    - ["system.boolean", "system.threading.spinlock", "Property[isthreadownertrackingenabled]"]
    - ["system.boolean", "system.threading.spinlock", "Property[isheldbycurrentthread]"]
    - ["system.threading.compressedstack", "system.threading.compressedstack", "Method[createcopy].ReturnValue"]
    - ["system.int64", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.threading.semaphore", "system.threading.semaphoreAcl!", "Method[create].ReturnValue"]
    - ["system.threading.tasks.valuetask", "system.threading.timer", "Method[disposeasync].ReturnValue"]
    - ["system.boolean", "system.threading.semaphore!", "Method[tryopenexisting].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtoken!", "Method[op_equality].ReturnValue"]
    - ["system.intptr", "system.threading.waithandle", "Property[handle]"]
    - ["system.threading.waithandle", "system.threading.countdownevent", "Property[waithandle]"]
    - ["system.int64", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.boolean", "system.threading.lockcookie!", "Method[op_inequality].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtokensource", "Property[iscancellationrequested]"]
    - ["system.uintptr", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtoken", "Property[canbecanceled]"]
    - ["system.uint32", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.uint64", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["t", "System.threading.Interlocked!", "Method[CompareExchange<t>].ReturnValue"]
    - ["system.object", "system.threading.thread!", "Method[getdata].ReturnValue"]
    - ["system.boolean", "system.threading.threadpool!", "Method[queueuserworkitem<tstate>].ReturnValue"]
    - ["system.threading.lockrecursionpolicy", "system.threading.lockrecursionpolicy!", "Field[supportsrecursion]"]
    - ["system.threading.cancellationtokenregistration", "system.threading.cancellationtoken", "Method[register].ReturnValue"]
    - ["system.sbyte", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int64", "system.threading.monitor!", "Property[lockcontentioncount]"]
    - ["system.boolean", "system.threading.waithandle!", "Method[waitall].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlock", "Property[isreaderlockheld]"]
    - ["system.int32", "system.threading.interlocked!", "Method[decrement].ReturnValue"]
    - ["system.int64", "system.threading.interlocked!", "Method[and].ReturnValue"]
    - ["system.threading.semaphore", "system.threading.semaphore!", "Method[openexisting].ReturnValue"]
    - ["system.int32", "system.threading.overlapped", "Property[offsetlow]"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Property[isreadlockheld]"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Property[isupgradeablereadlockheld]"]
    - ["system.int32", "system.threading.semaphoreslim", "Method[release].ReturnValue"]
    - ["system.threading.lazythreadsafetymode", "system.threading.lazythreadsafetymode!", "Field[publicationonly]"]
    - ["system.boolean", "system.threading.manualresetevent", "Method[reset].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Field[belownormal]"]
    - ["system.uint16", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.uintptr", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.nativeoverlapped*", "system.threading.threadpoolboundhandle", "Method[allocatenativeoverlapped].ReturnValue"]
    - ["system.threading.lockcookie", "system.threading.readerwriterlock", "Method[releaselock].ReturnValue"]
    - ["system.sbyte", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.boolean", "system.threading.timer", "Method[change].ReturnValue"]
    - ["system.localdatastoreslot", "system.threading.thread!", "Method[allocatenameddataslot].ReturnValue"]
    - ["system.boolean", "system.threading.synchronizationcontext", "Method[iswaitnotificationrequired].ReturnValue"]
    - ["system.uint64", "system.threading.interlocked!", "Method[add].ReturnValue"]
    - ["system.intptr", "system.threading.nativeoverlapped", "Field[internallow]"]
    - ["system.int32", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int32", "system.threading.synchronizationcontext!", "Method[waithelper].ReturnValue"]
    - ["system.threading.tasks.task", "system.threading.semaphoreslim", "Method[waitasync].ReturnValue"]
    - ["system.boolean", "system.threading.eventwaithandle!", "Method[tryopenexisting].ReturnValue"]
    - ["system.boolean", "system.threading.eventwaithandle", "Method[set].ReturnValue"]
    - ["system.int32", "system.threading.thread", "Property[managedthreadid]"]
    - ["system.boolean", "system.threading.threadpool!", "Method[queueuserworkitem].ReturnValue"]
    - ["system.threading.mutex", "system.threading.abandonedmutexexception", "Property[mutex]"]
    - ["system.boolean", "system.threading.threadpool!", "Method[bindhandle].ReturnValue"]
    - ["system.threading.eventwaithandle", "system.threading.eventwaithandleAcl!", "Method[create].ReturnValue"]
    - ["system.int32", "system.threading.manualreseteventslim", "Property[spincount]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[background]"]
    - ["system.int32", "system.threading.thread!", "Method[getdomainid].ReturnValue"]
    - ["system.boolean", "system.threading.spinwait", "Property[nextspinwillyield]"]
    - ["system.boolean", "system.threading.semaphoreacl!", "Method[tryopenexisting].ReturnValue"]
    - ["system.boolean", "system.threading.manualreseteventslim", "Method[wait].ReturnValue"]
    - ["system.int32", "system.threading.thread", "Method[gethashcode].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlock", "Method[anywriterssince].ReturnValue"]
    - ["system.int32", "system.threading.nativeoverlapped", "Field[offsethigh]"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Property[iswritelockheld]"]
    - ["system.int32", "system.threading.cancellationtoken", "Method[gethashcode].ReturnValue"]
    - ["system.byte", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.int32", "system.threading.overlapped", "Property[offsethigh]"]
    - ["system.object", "system.threading.threadabortexception", "Property[exceptionstate]"]
    - ["system.uint64", "system.threading.interlocked!", "Method[increment].ReturnValue"]
    - ["system.runtime.remoting.contexts.context", "system.threading.thread!", "Property[currentcontext]"]
    - ["system.boolean", "system.threading.cancellationtokenregistration", "Method[equals].ReturnValue"]
    - ["system.threading.apartmentstate", "system.threading.thread", "Property[apartmentstate]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[aborted]"]
    - ["system.threading.semaphore", "system.threading.semaphoreAcl!", "Method[openexisting].ReturnValue"]
    - ["system.boolean", "system.threading.thread", "Property[isthreadpoolthread]"]
    - ["system.double", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.threading.mutex", "system.threading.mutexAcl!", "Method[openexisting].ReturnValue"]
    - ["system.threading.threadpoolboundhandle", "system.threading.threadpoolboundhandle!", "Method[bindhandle].ReturnValue"]
    - ["system.boolean", "system.threading.spinlock", "Property[isheld]"]
    - ["system.uint16", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.timespan", "system.threading.timeout!", "Field[infinitetimespan]"]
    - ["system.threading.asyncflowcontrol", "system.threading.executioncontext!", "Method[suppressflow].ReturnValue"]
    - ["system.sbyte", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.waithandle", "system.threading.cancellationtoken", "Property[waithandle]"]
    - ["system.threading.eventwaithandle", "system.threading.eventwaithandle!", "Method[openexisting].ReturnValue"]
    - ["system.globalization.cultureinfo", "system.threading.thread", "Property[currentuiculture]"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Property[recursiveupgradecount]"]
    - ["system.boolean", "system.threading.waithandle!", "Method[signalandwait].ReturnValue"]
    - ["system.object", "system.threading.threadpoolboundhandle!", "Method[getnativeoverlappedstate].ReturnValue"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Property[waitingreadcount]"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Property[recursivewritecount]"]
    - ["system.threading.executioncontext", "system.threading.executioncontext!", "Method[capture].ReturnValue"]
    - ["system.int32", "system.threading.interlocked!", "Method[or].ReturnValue"]
    - ["system.boolean", "system.threading.threadpool!", "Method[setmaxthreads].ReturnValue"]
    - ["system.boolean", "system.threading.timer", "Method[dispose].ReturnValue"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Property[currentreadcount]"]
    - ["system.uint64", "system.threading.interlocked!", "Method[and].ReturnValue"]
    - ["system.boolean", "system.threading.autoresetevent", "Method[reset].ReturnValue"]
    - ["system.boolean", "system.threading.countdownevent", "Method[signal].ReturnValue"]
    - ["system.threading.cancellationtokenregistration", "system.threading.cancellationtoken", "Method[unsaferegister].ReturnValue"]
    - ["system.int32", "system.threading.spinwait", "Property[count]"]
    - ["system.boolean", "system.threading.monitor!", "Method[tryenter].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Method[tryenterwritelock].ReturnValue"]
    - ["system.int32", "system.threading.barrier", "Property[participantsremaining]"]
    - ["microsoft.win32.safehandles.safewaithandle", "system.threading.waithandleextensions!", "Method[getsafewaithandle].ReturnValue"]
    - ["system.boolean", "system.threading.threadpool!", "Method[unsafequeuenativeoverlapped].ReturnValue"]
    - ["system.localdatastoreslot", "system.threading.thread!", "Method[allocatedataslot].ReturnValue"]
    - ["system.boolean", "system.threading.itimer", "Method[change].ReturnValue"]
    - ["system.boolean", "system.threading.thread", "Property[isbackground]"]
    - ["system.security.accesscontrol.eventwaithandlesecurity", "system.threading.eventwaithandle", "Method[getaccesscontrol].ReturnValue"]
    - ["system.uint32", "system.threading.interlocked!", "Method[or].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtoken", "Property[iscancellationrequested]"]
    - ["system.boolean", "system.threading.threadpool!", "Method[setminthreads].ReturnValue"]
    - ["t", "System.threading.LazyInitializer!", "Method[EnsureInitialized<t>].ReturnValue"]
    - ["system.single", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.int32", "system.threading.asyncflowcontrol", "Method[gethashcode].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Method[tryenterupgradeablereadlock].ReturnValue"]
    - ["system.uint32", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.uint32", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.threading.waithandle", "system.threading.manualreseteventslim", "Property[waithandle]"]
    - ["system.uint64", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.eventwaithandle", "system.threading.eventwaithandleAcl!", "Method[openexisting].ReturnValue"]
    - ["system.threading.cancellationtoken", "system.threading.cancellationtoken!", "Property[none]"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Field[highest]"]
    - ["system.boolean", "system.threading.threadpool!", "Method[unsafequeueuserworkitem].ReturnValue"]
    - ["system.threading.executioncontext", "system.threading.thread", "Property[executioncontext]"]
    - ["system.int64", "system.threading.threadpool!", "Property[completedworkitemcount]"]
    - ["system.exception", "system.threading.threadexceptioneventargs", "Property[exception]"]
    - ["system.threading.lazythreadsafetymode", "system.threading.lazythreadsafetymode!", "Field[executionandpublication]"]
    - ["system.uint16", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.threading.cancellationtoken", "system.threading.cancellationtokenSource", "Property[token]"]
    - ["system.int64", "system.threading.interlocked!", "Method[read].ReturnValue"]
    - ["system.int32", "system.threading.semaphoreslim", "Property[currentcount]"]
    - ["system.threading.overlapped", "system.threading.overlapped!", "Method[unpack].ReturnValue"]
    - ["system.boolean", "system.threading.lockcookie", "Method[equals].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Field[lowest]"]
    - ["system.int32", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.threading.compressedstack", "system.threading.thread", "Method[getcompressedstack].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[suspendrequested]"]
    - ["system.boolean", "system.threading.registeredwaithandle", "Method[unregister].ReturnValue"]
    - ["system.boolean", "system.threading.threadpool!", "Method[unsafequeueuserworkitem<tstate>].ReturnValue"]
    - ["system.single", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.int64", "system.threading.interlocked!", "Method[or].ReturnValue"]
    - ["system.int16", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.int64", "system.threading.interlocked!", "Method[add].ReturnValue"]
    - ["system.uint64", "system.threading.interlocked!", "Method[or].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[running]"]
    - ["t", "System.threading.Volatile!", "Method[Read<t>].ReturnValue"]
    - ["system.int32", "system.threading.lockcookie", "Method[gethashcode].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtokenregistration", "Method[unregister].ReturnValue"]
    - ["system.byte", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Property[recursivereadcount]"]
    - ["system.int64", "system.threading.threadpool!", "Property[pendingworkitemcount]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[stopped]"]
    - ["system.boolean", "system.threading.thread!", "Method[yield].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtoken", "Method[equals].ReturnValue"]
    - ["system.int32", "system.threading.interlocked!", "Method[increment].ReturnValue"]
    - ["system.threading.hostexecutioncontext", "system.threading.hostexecutioncontext", "Method[createcopy].ReturnValue"]
    - ["system.intptr", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.appdomain", "system.threading.thread!", "Method[getdomain].ReturnValue"]
    - ["system.intptr", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.boolean", "system.threading.eventwaithandle", "Method[reset].ReturnValue"]
    - ["system.threading.lock+scope", "system.threading.lock", "Method[enterscope].ReturnValue"]
    - ["system.security.principal.iprincipal", "system.threading.thread!", "Property[currentprincipal]"]
    - ["system.uint32", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.boolean", "system.threading.lock", "Method[tryenter].ReturnValue"]
    - ["system.threading.preallocatedoverlapped", "system.threading.preallocatedoverlapped!", "Method[unsafecreate].ReturnValue"]
    - ["system.boolean", "system.threading.thread", "Method[trysetapartmentstate].ReturnValue"]
    - ["system.int32", "system.threading.timeout!", "Field[infinite]"]
    - ["system.double", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int32", "system.threading.countdownevent", "Property[initialcount]"]
    - ["system.boolean", "system.threading.executioncontext!", "Method[isflowsuppressed].ReturnValue"]
    - ["system.threading.apartmentstate", "system.threading.apartmentstate!", "Field[unknown]"]
    - ["system.double", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.int32", "system.threading.barrier", "Property[participantcount]"]
    - ["system.threading.synchronizationcontext", "system.threading.synchronizationcontext", "Method[createcopy].ReturnValue"]
    - ["system.object", "system.threading.hostexecutioncontextmanager", "Method[sethostexecutioncontext].ReturnValue"]
    - ["system.int64", "system.threading.barrier", "Method[addparticipant].ReturnValue"]
    - ["system.boolean", "system.threading.mutexacl!", "Method[tryopenexisting].ReturnValue"]
    - ["system.intptr", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.eventresetmode", "system.threading.eventresetmode!", "Field[autoreset]"]
    - ["system.threading.apartmentstate", "system.threading.apartmentstate!", "Field[mta]"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Method[tryenterreadlock].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Field[normal]"]
    - ["system.intptr", "system.threading.waithandle!", "Field[invalidhandle]"]
    - ["system.uintptr", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.boolean", "system.threading.spinwait!", "Method[spinuntil].ReturnValue"]
    - ["system.boolean", "system.threading.lock", "Property[isheldbycurrentthread]"]
    - ["system.boolean", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.object", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.threading.nativeoverlapped*", "system.threading.overlapped", "Method[pack].ReturnValue"]
    - ["system.threading.lockcookie", "system.threading.readerwriterlock", "Method[upgradetowriterlock].ReturnValue"]
    - ["system.boolean", "system.threading.autoresetevent", "Method[set].ReturnValue"]
    - ["system.int32", "system.threading.overlapped", "Property[eventhandle]"]
    - ["system.boolean", "system.threading.cancellationtokenregistration!", "Method[op_equality].ReturnValue"]
    - ["system.threading.tasks.valuetask", "system.threading.cancellationtokenregistration", "Method[disposeasync].ReturnValue"]
    - ["system.uint32", "system.threading.interlocked!", "Method[and].ReturnValue"]
    - ["system.int32", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.security.accesscontrol.mutexsecurity", "system.threading.mutex", "Method[getaccesscontrol].ReturnValue"]
    - ["system.security.accesscontrol.semaphoresecurity", "system.threading.threadingaclextensions!", "Method[getaccesscontrol].ReturnValue"]
    - ["system.boolean", "system.threading.mutex!", "Method[tryopenexisting].ReturnValue"]
    - ["system.int64", "system.threading.barrier", "Method[addparticipants].ReturnValue"]
    - ["system.threading.tasks.task<system.boolean>", "system.threading.semaphoreslim", "Method[waitasync].ReturnValue"]
    - ["system.security.accesscontrol.semaphoresecurity", "system.threading.semaphore", "Method[getaccesscontrol].ReturnValue"]
    - ["system.int32", "system.threading.interlocked!", "Method[and].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[unstarted]"]
    - ["system.threading.eventresetmode", "system.threading.eventresetmode!", "Field[manualreset]"]
    - ["system.int64", "system.threading.interlocked!", "Method[decrement].ReturnValue"]
    - ["system.object", "system.threading.hostexecutioncontext", "Property[state]"]
    - ["system.threading.compressedstack", "system.threading.compressedstack!", "Method[getcompressedstack].ReturnValue"]
    - ["system.sbyte", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.boolean", "system.threading.countdownevent", "Method[wait].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtoken!", "Method[op_inequality].ReturnValue"]
    - ["system.string", "system.threading.thread", "Property[name]"]
    - ["system.byte", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.int16", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.int32", "system.threading.semaphore", "Method[release].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtokensource", "Method[tryreset].ReturnValue"]
    - ["system.threading.registeredwaithandle", "system.threading.threadpool!", "Method[unsaferegisterwaitforsingleobject].ReturnValue"]
    - ["system.int64", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[stoprequested]"]
    - ["system.boolean", "system.threading.asyncflowcontrol", "Method[equals].ReturnValue"]
    - ["system.boolean", "system.threading.asyncflowcontrol!", "Method[op_inequality].ReturnValue"]
    - ["system.boolean", "system.threading.barrier", "Method[signalandwait].ReturnValue"]
    - ["system.iasyncresult", "system.threading.overlapped", "Property[asyncresult]"]
    - ["system.boolean", "system.threading.asyncflowcontrol!", "Method[op_equality].ReturnValue"]
    - ["system.byte", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[abortrequested]"]
    - ["system.int32", "system.threading.thread!", "Method[getcurrentprocessorid].ReturnValue"]
    - ["system.single", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.object", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.boolean", "system.threading.manualreseteventslim", "Property[isset]"]
    - ["system.double", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.threading.hostexecutioncontext", "system.threading.hostexecutioncontextManager", "Method[capture].ReturnValue"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Property[waitingupgradecount]"]
    - ["system.threading.thread", "system.threading.thread!", "Property[currentthread]"]
    - ["system.int64", "system.threading.interlocked!", "Method[increment].ReturnValue"]
    - ["system.threading.lockrecursionpolicy", "system.threading.lockrecursionpolicy!", "Field[norecursion]"]
    - ["system.boolean", "system.threading.eventwaithandleacl!", "Method[tryopenexisting].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.thread", "Property[priority]"]
    - ["system.boolean", "system.threading.readerwriterlock", "Property[iswriterlockheld]"]
    - ["system.threading.threadstate", "system.threading.thread", "Property[threadstate]"]
    - ["system.uint64", "system.threading.interlocked!", "Method[decrement].ReturnValue"]
    - ["system.threading.registeredwaithandle", "system.threading.threadpool!", "Method[registerwaitforsingleobject].ReturnValue"]
    - ["system.boolean", "system.threading.thread", "Property[isalive]"]
    - ["system.int32", "system.threading.readerwriterlock", "Property[writerseqnum]"]
    - ["system.boolean", "system.threading.semaphoreslim", "Method[wait].ReturnValue"]
    - ["system.intptr", "system.threading.nativeoverlapped", "Field[eventhandle]"]
    - ["system.boolean", "system.threading.cancellationtokenregistration!", "Method[op_inequality].ReturnValue"]
    - ["system.threading.synchronizationcontext", "system.threading.synchronizationcontext!", "Property[current]"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Property[waitingwritecount]"]
    - ["microsoft.win32.safehandles.safewaithandle", "system.threading.waithandle", "Property[safewaithandle]"]
    - ["system.threading.apartmentstate", "system.threading.apartmentstate!", "Field[sta]"]
    - ["system.int32", "system.threading.synchronizationcontext", "Method[wait].ReturnValue"]
    - ["system.threading.tasks.task", "system.threading.cancellationtokensource", "Method[cancelasync].ReturnValue"]
    - ["system.security.accesscontrol.mutexsecurity", "system.threading.threadingaclextensions!", "Method[getaccesscontrol].ReturnValue"]
    - ["system.threading.apartmentstate", "system.threading.thread", "Method[getapartmentstate].ReturnValue"]
    - ["system.uintptr", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.int32", "system.threading.abandonedmutexexception", "Property[mutexindex]"]
    - ["system.int32", "system.threading.nativeoverlapped", "Field[offsetlow]"]
    - ["system.localdatastoreslot", "system.threading.thread!", "Method[getnameddataslot].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[suspended]"]
    - ["system.runtime.interopservices.safehandle", "system.threading.threadpoolboundhandle", "Property[handle]"]
    - ["system.uint64", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.int32", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.boolean", "system.threading.thread", "Method[join].ReturnValue"]
    - ["system.threading.nativeoverlapped*", "system.threading.overlapped", "Method[unsafepack].ReturnValue"]
    - ["system.boolean", "system.threading.manualresetevent", "Method[set].ReturnValue"]
    - ["system.boolean", "system.threading.waithandle", "Method[waitone].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Field[waitsleepjoin]"]
    - ["system.security.accesscontrol.eventwaithandlesecurity", "system.threading.threadingaclextensions!", "Method[getaccesscontrol].ReturnValue"]
    - ["t", "System.threading.Interlocked!", "Method[Exchange<t>].ReturnValue"]
    - ["system.globalization.cultureinfo", "system.threading.thread", "Property[currentculture]"]
    - ["system.uint32", "system.threading.interlocked!", "Method[increment].ReturnValue"]
    - ["system.timespan", "system.threading.periodictimer", "Property[period]"]
    - ["system.threading.mutex", "system.threading.mutex!", "Method[openexisting].ReturnValue"]
    - ["system.uint64", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int16", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.int32", "system.threading.waithandle!", "Field[waittimeout]"]
    - ["system.threading.compressedstack", "system.threading.compressedstack!", "Method[capture].ReturnValue"]
    - ["system.threading.nativeoverlapped*", "system.threading.threadpoolboundhandle", "Method[unsafeallocatenativeoverlapped].ReturnValue"]
    - ["system.intptr", "system.threading.nativeoverlapped", "Field[internalhigh]"]
    - ["system.int64", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.uint32", "system.threading.interlocked!", "Method[decrement].ReturnValue"]
    - ["system.intptr", "system.threading.overlapped", "Property[eventhandleintptr]"]
